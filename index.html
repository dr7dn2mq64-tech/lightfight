<!DOCTYPE html>
<html lang="zh-CN">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <meta name="mobile-web-app-capable" content="yes">
   <meta name="apple-mobile-web-app-capable" content="yes">
   <title>LightFight</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
   <style>
       * { touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
       body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; touch-action: none; }
       #gameCanvas { display: block; width: 100%; height: 100%; }
       .hud-text { text-shadow: 0 0 10px rgba(0, 255, 255, 0.8); }
       .menu-panel { background: rgba(0, 0, 0, 0.95); border: 2px solid #0ff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
       .neon-btn { background: linear-gradient(45deg, #000, #0ff); border: 1px solid #0ff; color: #fff; text-shadow: 0 0 5px #0ff; transition: all 0.3s; touch-action: manipulation; }
       .neon-btn:hover, .neon-btn:active { background: #0ff; color: #000; box-shadow: 0 0 20px #0ff; }
       .slot { background: rgba(0, 50, 50, 0.5); border: 1px solid #0ff; }
       .slot:hover { background: rgba(0, 255, 255, 0.2); }
       #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid #0ff; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 10; }
       .damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.5) 100%); pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 5; }
       
       .mobile-controls { display: none; position: absolute; bottom: 20px; width: 100%; height: 200px; z-index: 20; pointer-events: none; }
       .mobile-controls.active { display: flex; }
       .joystick-area { position: absolute; left: 20px; bottom: 20px; width: 150px; height: 150px; pointer-events: auto; }
       .joystick-base { position: absolute; width: 120px; height: 120px; background: rgba(0, 255, 255, 0.2); border: 2px solid #0ff; border-radius: 50%; }
       .joystick-knob { position: absolute; width: 50px; height: 50px; background: rgba(0, 255, 255, 0.6); border-radius: 50%; top: 35px; left: 35px; }
       
       .aim-area { position: absolute; right: 20px; bottom: 20px; width: 150px; height: 150px; pointer-events: auto; }
       .aim-knob { position: absolute; width: 60px; height: 60px; background: rgba(255, 0, 0, 0.4); border: 2px solid #f00; border-radius: 50%; top: 45px; left: 45px; }
       
       .mobile-btns { position: absolute; right: 180px; bottom: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
       .mobile-btn { width: 60px; height: 60px; background: rgba(0, 255, 255, 0.3); border: 2px solid #0ff; border-radius: 50%; color: #0ff; font-size: 12px; display: flex; align-items: center; justify-content: center; font-weight: bold; }
       .mobile-btn:active { background: rgba(0, 255, 255, 0.6); }
       .fire-btn { position: absolute; right: 20px; bottom: 180px; width: 80px; height: 80px; background: rgba(255, 0, 0, 0.4); border: 3px solid #f00; border-radius: 50%; pointer-events: auto; }
       .fire-btn:active { background: rgba(255, 0, 0, 0.7); transform: scale(0.95); }
       
       @media (max-width: 1024px) {
           .mobile-controls { display: flex; }
           #crosshair { opacity: 0.5; }
       }
       
       .scroll-container { overflow-y: auto; max-height: 60vh; scrollbar-width: thin; scrollbar-color: #0ff #000; }
       .scroll-container::-webkit-scrollbar { width: 8px; }
       .scroll-container::-webkit-scrollbar-track { background: #000; }
       .scroll-container::-webkit-scrollbar-thumb { background: #0ff; border-radius: 4px; }
   </style>
</head>
<body>

<div id="mainMenu" class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black overflow-auto">
   <h1 class="text-6xl md:text-8xl font-bold text-transparent bg-clip-text bg-gradient-to-b from-cyan-400 to-blue-600 mb-4 md:mb-8 hud-text tracking-widest text-center px-4">LIGHTFIGHT</h1>
   <div class="flex flex-col gap-2 md:gap-4 w-full max-w-xs md:max-w-md px-4">
       <button onclick="game.startMode('story')" class="neon-btn py-3 md:py-4 px-6 md:px-8 text-lg md:text-xl font-bold rounded">å‰§æƒ…æ¨¡å¼</button>
       <button onclick="game.startMode('endless')" class="neon-btn py-3 md:py-4 px-6 md:px-8 text-lg md:text-xl font-bold rounded">æ— å°½æ¨¡å¼</button>
       <button onclick="game.startMode('level')" class="neon-btn py-3 md:py-4 px-6 md:px-8 text-lg md:text-xl font-bold rounded">é—¯å…³æ¨¡å¼</button>
       <button onclick="game.startMode('survival')" class="neon-btn py-3 md:py-4 px-6 md:px-8 text-lg md:text-xl font-bold rounded">ç”Ÿå­˜æ¨¡å¼</button>
       <button onclick="game.startMode('creator')" class="neon-btn py-3 md:py-4 px-6 md:px-8 text-lg md:text-xl font-bold rounded">é€ ç‰©ä¸»æ¨¡å¼</button>
       <div class="grid grid-cols-2 gap-2 mt-2">
           <button onclick="ui.showStore()" class="neon-btn py-2 px-4 text-base font-bold rounded">å•†åº—</button>
           <button onclick="ui.showInventory()" class="neon-btn py-2 px-4 text-base font-bold rounded">èƒŒåŒ…</button>
           <button onclick="ui.showWarehouse()" class="neon-btn py-2 px-4 text-base font-bold rounded">ä»“åº“</button>
           <button onclick="ui.showQuests()" class="neon-btn py-2 px-4 text-base font-bold rounded">ä»»åŠ¡</button>
           <button onclick="ui.showArena()" class="neon-btn py-2 px-4 text-base font-bold rounded col-span-2">ç«æŠ€åœº</button>
       </div>
   </div>
   <div class="mt-4 text-cyan-600 text-xs md:text-sm text-center px-4">
       <span class="md:hidden">ç§»åŠ¨ç«¯ï¼šå·¦ä¾§æ‘‡æ†ç§»åŠ¨ï¼Œå³ä¾§ç„å‡†ï¼Œçº¢è‰²æŒ‰é’®å°„å‡»</span>
       <span class="hidden md:inline">PCç«¯ï¼šWASDç§»åŠ¨ï¼Œé¼ æ ‡ç„å‡†ï¼Œå·¦é”®å°„å‡»</span>
   </div>
</div>

<div id="gameUI" class="hidden absolute inset-0 z-40 pointer-events-none">
   <div class="damage-overlay" id="damageOverlay"></div>
   <div id="crosshair"></div>
   
   <div class="absolute top-2 left-2 md:top-4 md:left-4 text-cyan-400 text-sm md:text-base">
       <div class="font-bold hud-text">HP: <span id="hpDisplay">100</span>/100</div>
       <div class="hud-text">å¼¹è¯: <span id="ammoDisplay">30</span>/90</div>
       <div class="hud-text">åˆ†æ•°: <span id="scoreDisplay">0</span></div>
       <div class="hud-text text-xs md:text-base">æ³¢æ¬¡: <span id="waveDisplay">1</span></div>
   </div>
   
   <div class="absolute top-2 right-2 md:top-4 md:right-4 text-cyan-400 text-right text-xs md:text-base">
       <div class="hud-text"><span id="weaponDisplay">æ­¥æª</span></div>
       <div class="hud-text text-xs"><span id="viewDisplay">ç¬¬ä¸€äººç§°</span></div>
       <div class="hud-text text-yellow-400">ğŸ’° <span id="goldDisplay">0</span></div>
   </div>
   
   <div class="absolute bottom-20 left-2 md:bottom-4 md:left-4 text-cyan-400 text-xs hidden md:block">
       <div>[WASD]ç§»åŠ¨ [é¼ æ ‡]ç„å‡† [å·¦é”®]å°„å‡» [å³é”®]ç„å‡† [R]æ¢å¼¹ [V]åˆ‡æ¢è§†è§’ [Tab]èœå• [B]èƒŒåŒ…</div>
   </div>

   <div class="mobile-controls" id="mobileControls">
       <div class="joystick-area" id="moveJoystick">
           <div class="joystick-base"></div>
           <div class="joystick-knob" id="moveKnob"></div>
       </div>
       
       <div class="aim-area" id="aimJoystick">
           <div class="joystick-base" style="opacity: 0.3;"></div>
           <div class="aim-knob" id="aimKnob"></div>
       </div>
       
       <div class="mobile-btns">
           <button class="mobile-btn" onclick="game.reload()">æ¢å¼¹</button>
           <button class="mobile-btn" onclick="game.switchView()">è§†è§’</button>
           <button class="mobile-btn" onclick="game.togglePause()">èœå•</button>
       </div>
       
       <div class="fire-btn" id="fireBtn" onmousedown="game.startFiring()" onmouseup="game.stopFiring()" ontouchstart="game.startFiring()" ontouchend="game.stopFiring()"></div>
   </div>
</div>

<div id="pauseMenu" class="hidden absolute inset-0 z-50 flex flex-col items-center justify-center bg-black bg-opacity-95">
   <h2 class="text-4xl md:text-6xl font-bold text-cyan-400 mb-8 hud-text">æš‚åœ</h2>
   <div class="flex flex-col gap-4 w-64 px-4">
       <button onclick="game.resume()" class="neon-btn py-3 px-6 text-lg font-bold rounded">ç»§ç»­æ¸¸æˆ</button>
       <button onclick="ui.showInventory()" class="neon-btn py-3 px-6 text-lg font-bold rounded pointer-events-auto">æ‰“å¼€èƒŒåŒ…</button>
       <button onclick="game.returnToMenu()" class="neon-btn py-3 px-6 text-lg font-bold rounded">è¿”å›ä¸»èœå•</button>
   </div>
</div>

<div id="storeModal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black bg-opacity-95 p-4">
   <div class="menu-panel p-4 md:p-8 rounded-lg w-full max-w-4xl h-full md:h-4/5 flex flex-col">
       <div class="flex justify-between items-center mb-4">
           <h2 class="text-2xl md:text-4xl font-bold text-cyan-400 hud-text">æ­¦å™¨å•†åº—</h2>
           <button onclick="ui.closeModal('storeModal')" class="text-red-500 text-2xl font-bold hover:text-red-400 p-2">Ã—</button>
       </div>
       <div class="text-cyan-400 mb-4 text-lg">é‡‘å¸: <span id="storeGold">0</span></div>
       <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 overflow-auto flex-1 scroll-container" id="storeGrid"></div>
   </div>
</div>

<div id="inventoryModal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black bg-opacity-95 p-4">
   <div class="menu-panel p-4 md:p-8 rounded-lg w-full max-w-4xl h-full md:h-4/5 flex flex-col">
       <div class="flex justify-between items-center mb-4">
           <h2 class="text-2xl md:text-4xl font-bold text-cyan-400 hud-text">èƒŒåŒ…</h2>
           <button onclick="ui.closeModal('inventoryModal')" class="text-red-500 text-2xl font-bold hover:text-red-400 p-2">Ã—</button>
       </div>
       <div class="grid grid-cols-4 md:grid-cols-8 gap-2 mb-4" id="inventoryGrid"></div>
       <div class="text-cyan-400 mt-4">
           <h3 class="text-xl mb-2">å·²è£…å¤‡</h3>
           <div class="flex flex-wrap gap-4" id="equippedItems"></div>
       </div>
   </div>
</div>

<div id="warehouseModal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black bg-opacity-95 p-4">
   <div class="menu-panel p-4 md:p-8 rounded-lg w-full max-w-4xl h-full md:h-4/5 flex flex-col">
       <div class="flex justify-between items-center mb-4">
           <h2 class="text-2xl md:text-4xl font-bold text-cyan-400 hud-text">ä»“åº“</h2>
           <button onclick="ui.closeModal('warehouseModal')" class="text-red-500 text-2xl font-bold hover:text-red-400 p-2">Ã—</button>
       </div>
       <div class="grid grid-cols-5 md:grid-cols-10 gap-2 overflow-auto flex-1 scroll-container" id="warehouseGrid"></div>
   </div>
</div>

<div id="questModal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black bg-opacity-95 p-4">
   <div class="menu-panel p-4 md:p-8 rounded-lg w-full max-w-3xl h-3/4 flex flex-col">
       <div class="flex justify-between items-center mb-4">
           <h2 class="text-2xl md:text-4xl font-bold text-cyan-400 hud-text">ä»»åŠ¡ä¸­å¿ƒ</h2>
           <button onclick="ui.closeModal('questModal')" class="text-red-500 text-2xl font-bold hover:text-red-400 p-2">Ã—</button>
       </div>
       <div class="flex-1 overflow-auto space-y-4 scroll-container" id="questList"></div>
   </div>
</div>

<div id="arenaModal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black bg-opacity-95 p-4">
   <div class="menu-panel p-4 md:p-8 rounded-lg w-full max-w-md flex flex-col">
       <h2 class="text-2xl md:text-4xl font-bold text-cyan-400 mb-4 hud-text">ç«æŠ€åœº</h2>
       <p class="text-cyan-200 mb-4 text-sm md:text-base">æŒ‘æˆ˜å…¶ä»–ç©å®¶æˆ–AIï¼Œæå‡æ’å</p>
       <div class="space-y-2 mb-4 max-h-60 overflow-auto scroll-container" id="arenaList"></div>
       <button onclick="game.startArenaMatch()" class="neon-btn py-3 px-6 text-lg font-bold rounded mb-2">å¼€å§‹åŒ¹é…</button>
       <button onclick="ui.closeModal('arenaModal')" class="text-red-500 hover:text-red-400 py-2">å…³é—­</button>
   </div>
</div>

<div id="creatorModal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black bg-opacity-95 p-4">
   <div class="menu-panel p-4 md:p-8 rounded-lg w-full max-w-4xl h-full md:h-4/5 flex flex-col">
       <div class="flex justify-between items-center mb-4">
           <h2 class="text-2xl md:text-4xl font-bold text-cyan-400 hud-text">é€ ç‰©ä¸»æ¨¡å¼</h2>
           <button onclick="ui.closeModal('creatorModal'); game.returnToMenu()" class="text-red-500 text-2xl font-bold hover:text-red-400 p-2">Ã—</button>
       </div>
       <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
           <button onclick="creator.placeEnemy()" class="neon-btn py-2 rounded text-sm md:text-base">æ”¾ç½®æ•Œäºº</button>
           <button onclick="creator.placeWall()" class="neon-btn py-2 rounded text-sm md:text-base">æ”¾ç½®å¢™ä½“</button>
           <button onclick="creator.placeItem()" class="neon-btn py-2 rounded text-sm md:text-base">æ”¾ç½®ç‰©å“</button>
           <button onclick="creator.setSpawn()" class="neon-btn py-2 rounded text-sm md:text-base">è®¾ç½®å‡ºç”Ÿç‚¹</button>
           <button onclick="creator.saveMap()" class="neon-btn py-2 rounded text-sm md:text-base">ä¿å­˜åœ°å›¾</button>
           <button onclick="creator.loadMap()" class="neon-btn py-2 rounded text-sm md:text-base">åŠ è½½åœ°å›¾</button>
           <button onclick="creator.clearMap()" class="neon-btn py-2 rounded bg-red-900 text-sm md:text-base">æ¸…ç©ºåœ°å›¾</button>
           <button onclick="creator.testMap()" class="neon-btn py-2 rounded bg-green-900 text-sm md:text-base">æµ‹è¯•åœ°å›¾</button>
       </div>
       <div class="text-cyan-400 text-sm">ç‚¹å‡»åœºæ™¯æ”¾ç½®ç‰©ä½“ï¼Œå³é”®/åŒæŒ‡æ—‹è½¬è§†è§’</div>
   </div>
</div>

<script>
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

const game = {
   scene: null, camera: null, renderer: null, 
   player: { hp: 100, maxHp: 100, ammo: 30, maxAmmo: 30, reserveAmmo: 90, gold: 1000, speed: 0.15 },
   weapons: [
       { id: 'pistol', name: 'æ‰‹æª', damage: 25, fireRate: 300, auto: false, price: 0, unlocked: true },
       { id: 'rifle', name: 'çªå‡»æ­¥æª', damage: 35, fireRate: 100, auto: true, price: 500, unlocked: true },
       { id: 'sniper', name: 'ç‹™å‡»æª', damage: 100, fireRate: 1000, auto: false, price: 1200, unlocked: false },
       { id: 'shotgun', name: 'éœ°å¼¹æª', damage: 80, fireRate: 800, auto: false, price: 800, unlocked: false },
       { id: 'laser', name: 'æ¿€å…‰ç‚®', damage: 200, fireRate: 500, auto: false, price: 3000, unlocked: false }
   ],
   currentWeapon: null,
   enemies: [], bullets: [], items: [], particles: [],
   viewMode: 0,
   viewModes: ['ç¬¬ä¸€äººç§°', 'ç¬¬ä¸‰äººç§°', 'ç¬¬äºŒäººç§°'],
   isPlaying: false, isPaused: false, mode: '', wave: 1, score: 0,
   keys: {}, mouse: { x: 0, y: 0 }, raycaster: new THREE.Raycaster(),
   playerMesh: null, weaponMesh: null, thirdPersonCamera: null,
   lastShot: 0, enemySpawnTimer: 0, canvas: null,
   isFiring: false,
   
   touchData: { move: { active: false, startX: 0, startY: 0, dx: 0, dy: 0 }, aim: { active: false, startX: 0, startY: 0, dx: 0, dy: 0 } },
   
   init() {
       this.canvas = document.getElementById('gameCanvas');
       this.scene = new THREE.Scene();
       this.scene.fog = new THREE.Fog(0x000000, 0.1, 50);
       
       this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
       this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
       this.renderer.setSize(window.innerWidth, window.innerHeight);
       this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
       this.renderer.shadowMap.enabled = true;
       document.body.appendChild(this.renderer.domElement);
       
       this.setupLights();
       this.setupWorld();
       this.setupPlayer();
       this.setupEvents();
       this.setupMobileControls();
       this.currentWeapon = this.weapons[1];
       this.animate();
       
       if (isMobile) {
           document.getElementById('mobileControls').classList.add('active');
       }
   },
   
   setupLights() {
       const ambient = new THREE.AmbientLight(0x404040, 0.5);
       this.scene.add(ambient);
       
       const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
       dirLight.position.set(10, 20, 10);
       dirLight.castShadow = true;
       dirLight.shadow.mapSize.width = 2048;
       dirLight.shadow.mapSize.height = 2048;
       this.scene.add(dirLight);
       
       const pointLight = new THREE.PointLight(0x00ffff, 0.5, 20);
       pointLight.position.set(0, 5, 0);
       this.scene.add(pointLight);
   },
   
   setupWorld() {
       const floorGeo = new THREE.PlaneGeometry(100, 100);
       const floorMat = new THREE.MeshStandardMaterial({ 
           color: 0x111111, 
           roughness: 0.8,
           metalness: 0.2
       });
       const floor = new THREE.Mesh(floorGeo, floorMat);
       floor.rotation.x = -Math.PI / 2;
       floor.receiveShadow = true;
       this.scene.add(floor);
       
       const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x003333);
       this.scene.add(gridHelper);
       
       for (let i = 0; i < 20; i++) {
           this.createObstacle();
       }
   },
   
   createObstacle() {
       const size = Math.random() * 3 + 1;
       const geo = new THREE.BoxGeometry(size, size, size);
       const mat = new THREE.MeshStandardMaterial({ 
           color: Math.random() > 0.5 ? 0x0088ff : 0xff0088,
           emissive: Math.random() > 0.5 ? 0x0044aa : 0xaa0044,
           emissiveIntensity: 0.2
       });
       const mesh = new THREE.Mesh(geo, mat);
       mesh.position.set(
           (Math.random() - 0.5) * 80,
           size / 2,
           (Math.random() - 0.5) * 80
       );
       mesh.castShadow = true;
       mesh.receiveShadow = true;
       this.scene.add(mesh);
   },
   
   setupPlayer() {
       const geo = new THREE.CapsuleGeometry(0.5, 2, 4, 8);
       const mat = new THREE.MeshStandardMaterial({ color: 0x00ff00, visible: false });
       this.playerMesh = new THREE.Mesh(geo, mat);
       this.playerMesh.position.y = 1.5;
       this.scene.add(this.playerMesh);
       
       this.thirdPersonCamera = new THREE.Object3D();
       this.playerMesh.add(this.thirdPersonCamera);
       this.thirdPersonCamera.position.set(0, 1.5, -3);
       
       this.createWeaponMesh();
   },
   
   createWeaponMesh() {
       if (this.weaponMesh) this.scene.remove(this.weaponMesh);
       
       const group = new THREE.Group();
       
       if (this.currentWeapon.id === 'rifle') {
           const body = new THREE.Mesh(
               new THREE.BoxGeometry(0.1, 0.2, 0.8),
               new THREE.MeshStandardMaterial({ color: 0x333333 })
           );
           const barrel = new THREE.Mesh(
               new THREE.CylinderGeometry(0.03, 0.03, 0.4),
               new THREE.MeshStandardMaterial({ color: 0x111111 })
           );
           barrel.rotation.x = Math.PI / 2;
           barrel.position.z = 0.6;
           group.add(body, barrel);
       } else if (this.currentWeapon.id === 'pistol') {
           const body = new THREE.Mesh(
               new THREE.BoxGeometry(0.08, 0.15, 0.3),
               new THREE.MeshStandardMaterial({ color: 0x222222 })
           );
           const barrel = new THREE.Mesh(
               new THREE.CylinderGeometry(0.02, 0.02, 0.2),
               new THREE.MeshStandardMaterial({ color: 0x111111 })
           );
           barrel.rotation.x = Math.PI / 2;
           barrel.position.z = 0.25;
           group.add(body, barrel);
       } else {
           const body = new THREE.Mesh(
               new THREE.BoxGeometry(0.12, 0.25, 0.9),
               new THREE.MeshStandardMaterial({ color: 0x444444, emissive: 0x0044ff, emissiveIntensity: 0.3 })
           );
           group.add(body);
       }
       
       this.weaponMesh = group;
       this.scene.add(this.weaponMesh);
   },
   
   setupEvents() {
       document.addEventListener('keydown', (e) => {
           this.keys[e.code] = true;
           if (e.code === 'KeyR') this.reload();
           if (e.code === 'KeyV') this.switchView();
           if (e.code === 'Tab') { e.preventDefault(); this.togglePause(); }
           if (e.code === 'KeyB') { if (this.isPlaying) { this.togglePause(); ui.showInventory(); } }
       });
       document.addEventListener('keyup', (e) => this.keys[e.code] = false);
       
       if (!isMobile) {
           document.addEventListener('mousemove', (e) => {
               if (this.isPlaying && !this.isPaused && document.pointerLockElement === this.renderer.domElement) {
                   this.mouse.x += e.movementX * 0.002;
                   this.mouse.y += e.movementY * 0.002;
                   this.mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.mouse.y));
               }
           });
           
           document.addEventListener('mousedown', (e) => {
               if (e.button === 0 && this.isPlaying && !this.isPaused) {
                   this.startFiring();
               }
           });
           
           document.addEventListener('mouseup', (e) => {
               if (e.button === 0) this.stopFiring();
           });
           
           this.renderer.domElement.addEventListener('click', () => {
               if (this.isPlaying && !this.isPaused) {
                   this.renderer.domElement.requestPointerLock();
               }
           });
       }
       
       window.addEventListener('resize', () => {
           this.camera.aspect = window.innerWidth / window.innerHeight;
           this.camera.updateProjectionMatrix();
           this.renderer.setSize(window.innerWidth, window.innerHeight);
       });
       
       document.addEventListener('contextmenu', e => e.preventDefault());
   },
   
   setupMobileControls() {
       if (!isMobile) return;
       
       const moveJoystick = document.getElementById('moveJoystick');
       const moveKnob = document.getElementById('moveKnob');
       const aimJoystick = document.getElementById('aimJoystick');
       const aimKnob = document.getElementById('aimKnob');
       
       moveJoystick.addEventListener('touchstart', (e) => {
           e.preventDefault();
           const touch = e.touches[0];
           const rect = moveJoystick.getBoundingClientRect();
           this.touchData.move.active = true;
           this.touchData.move.startX = rect.left + rect.width / 2;
           this.touchData.move.startY = rect.top + rect.height / 2;
       }, { passive: false });
       
       moveJoystick.addEventListener('touchmove', (e) => {
           e.preventDefault();
           if (!this.touchData.move.active) return;
           const touch = e.touches[0];
           const maxDist = 35;
           let dx = touch.clientX - this.touchData.move.startX;
           let dy = touch.clientY - this.touchData.move.startY;
           const dist = Math.sqrt(dx * dx + dy * dy);
           if (dist > maxDist) {
               dx = (dx / dist) * maxDist;
               dy = (dy / dist) * maxDist;
           }
           moveKnob.style.transform = `translate(${dx}px, ${dy}px)`;
           this.touchData.move.dx = dx / maxDist;
           this.touchData.move.dy = dy / maxDist;
       }, { passive: false });
       
       moveJoystick.addEventListener('touchend', (e) => {
           e.preventDefault();
           this.touchData.move.active = false;
           this.touchData.move.dx = 0;
           this.touchData.move.dy = 0;
           moveKnob.style.transform = `translate(0, 0)`;
       }, { passive: false });
       
       aimJoystick.addEventListener('touchstart', (e) => {
           e.preventDefault();
           const touch = e.touches[0];
           const rect = aimJoystick.getBoundingClientRect();
           this.touchData.aim.active = true;
           this.touchData.aim.startX = rect.left + rect.width / 2;
           this.touchData.aim.startY = rect.top + rect.height / 2;
       }, { passive: false });
       
       aimJoystick.addEventListener('touchmove', (e) => {
           e.preventDefault();
           if (!this.touchData.aim.active) return;
           const touch = e.touches[0];
           const maxDist = 30;
           let dx = touch.clientX - this.touchData.aim.startX;
           let dy = touch.clientY - this.touchData.aim.startY;
           const dist = Math.sqrt(dx * dx + dy * dy);
           if (dist > maxDist) {
               dx = (dx / dist) * maxDist;
               dy = (dy / dist) * maxDist;
           }
           aimKnob.style.transform = `translate(${dx}px, ${dy}px)`;
           this.touchData.aim.dx = dx / maxDist * 0.05;
           this.touchData.aim.dy = dy / maxDist * 0.03;
       }, { passive: false });
       
       aimJoystick.addEventListener('touchend', (e) => {
           e.preventDefault();
           this.touchData.aim.active = false;
           this.touchData.aim.dx = 0;
           this.touchData.aim.dy = 0;
           aimKnob.style.transform = `translate(0, 0)`;
       }, { passive: false });
   },
   
   startFiring() {
       this.isFiring = true;
       if (this.currentWeapon.auto) {
           this.fireLoop();
       } else {
           this.shoot();
       }
   },
   
   stopFiring() {
       this.isFiring = false;
   },
   
   fireLoop() {
       if (!this.isFiring || !this.isPlaying || this.isPaused) return;
       this.shoot();
       setTimeout(() => this.fireLoop(), this.currentWeapon.fireRate);
   },
   
   switchView() {
       this.viewMode = (this.viewMode + 1) % 3;
       document.getElementById('viewDisplay').textContent = this.viewModes[this.viewMode];
       
       if (this.viewMode === 0) {
           this.playerMesh.material.visible = false;
       } else {
           this.playerMesh.material.visible = true;
       }
   },
   
   shoot() {
       const now = Date.now();
       if (now - this.lastShot < this.currentWeapon.fireRate) return;
       if (this.player.ammo <= 0) { this.reload(); return; }
       
       this.lastShot = now;
       this.player.ammo--;
       this.updateHUD();
       
       const recoil = Math.random() * 0.05;
       this.mouse.y += recoil;
       
       const bulletGeo = new THREE.SphereGeometry(0.05);
       const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
       const bullet = new THREE.Mesh(bulletGeo, bulletMat);
       
       let shootPos = this.playerMesh.position.clone();
       if (this.viewMode === 0) {
           shootPos.y += 1.6;
       } else {
           shootPos.y += 1.5;
       }
       
       bullet.position.copy(shootPos);
       bullet.position.add(this.getForwardVector().multiplyScalar(1));
       
       const velocity = this.getForwardVector().multiplyScalar(2);
       
       this.bullets.push({ mesh: bullet, velocity: velocity, damage: this.currentWeapon.damage, life: 100 });
       this.scene.add(bullet);
       
       if (this.currentWeapon.id === 'shotgun') {
           for (let i = 0; i < 5; i++) {
               const spreadBullet = bullet.clone();
               const spread = new THREE.Vector3(
                   (Math.random() - 0.5) * 0.3,
                   (Math.random() - 0.5) * 0.3,
                   (Math.random() - 0.5) * 0.3
               );
               this.bullets.push({ 
                   mesh: spreadBullet, 
                   velocity: velocity.clone().add(spread), 
                   damage: this.currentWeapon.damage / 5,
                   life: 100 
               });
               this.scene.add(spreadBullet);
           }
       }
       
       this.createMuzzleFlash();
       
       if (isMobile && navigator.vibrate) {
           navigator.vibrate(20);
       }
   },
   
   createMuzzleFlash() {
       const flash = new THREE.PointLight(0xffff00, 1, 5);
       let pos = this.playerMesh.position.clone();
       pos.y += 1.5;
       pos.add(this.getForwardVector().multiplyScalar(1));
       flash.position.copy(pos);
       this.scene.add(flash);
       setTimeout(() => this.scene.remove(flash), 50);
   },
   
   reload() {
       if (this.player.reserveAmmo <= 0 || this.player.ammo === this.player.maxAmmo) return;
       const needed = this.player.maxAmmo - this.player.ammo;
       const available = Math.min(needed, this.player.reserveAmmo);
       this.player.ammo += available;
       this.player.reserveAmmo -= available;
       this.updateHUD();
   },
   
   spawnEnemy() {
       const types = [
           { name: 'å·¡é€»è€…', hp: 50, speed: 0.05, color: 0xff0000, damage: 10, reward: 50 },
           { name: 'è¿½çŒè€…', hp: 80, speed: 0.08, color: 0xff4400, damage: 15, reward: 80 },
           { name: 'é‡è£…æœºå…µ', hp: 200, speed: 0.03, color: 0x880000, damage: 25, reward: 150 },
           { name: 'æš—å½±åˆºå®¢', hp: 40, speed: 0.12, color: 0x440044, damage: 20, reward: 100 }
       ];
       
       const type = types[Math.floor(Math.random() * Math.min(types.length, this.wave))];
       const geo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
       const mat = new THREE.MeshStandardMaterial({ color: type.color, emissive: type.color, emissiveIntensity: 0.3 });
       const mesh = new THREE.Mesh(geo, mat);
       
       const angle = Math.random() * Math.PI * 2;
       const dist = 20 + Math.random() * 20;
       mesh.position.set(
           this.playerMesh.position.x + Math.cos(angle) * dist,
           0.9,
           this.playerMesh.position.z + Math.sin(angle) * dist
       );
       
       mesh.castShadow = true;
       this.scene.add(mesh);
       
       this.enemies.push({
           mesh: mesh,
           hp: type.hp,
           maxHp: type.hp,
           speed: type.speed,
           damage: type.damage,
           reward: type.reward,
           type: type.name,
           lastAttack: 0
       });
   },
   
   update() {
       if (!this.isPlaying || this.isPaused) return;
       
       this.updateMovement();
       this.updateCamera();
       this.updateBullets();
       this.updateEnemies();
       this.updateParticles();
       
       this.enemySpawnTimer++;
       const spawnRate = Math.max(60, 300 - this.wave * 10);
       if (this.enemySpawnTimer > spawnRate) {
           this.spawnEnemy();
           this.enemySpawnTimer = 0;
       }
       
       if (this.enemies.length === 0 && this.enemySpawnTimer > 30) {
           this.wave++;
           this.player.gold += 100;
           this.updateHUD();
           for (let i = 0; i < this.wave + 2; i++) this.spawnEnemy();
       }
   },
   
   updateMovement() {
       let moveForward = 0;
       let moveRight = 0;
       
       if (isMobile && this.touchData.move.active) {
           moveForward = -this.touchData.move.dy;
           moveRight = this.touchData.move.dx;
       } else {
           if (this.keys['KeyW']) moveForward += 1;
           if (this.keys['KeyS']) moveForward -= 1;
           if (this.keys['KeyA']) moveRight -= 1;
           if (this.keys['KeyD']) moveRight += 1;
       }
       
       const forward = this.getForwardVector();
       const right = new THREE.Vector3();
       right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
       
       const move = new THREE.Vector3();
       move.add(forward.multiplyScalar(moveForward));
       move.add(right.multiplyScalar(moveRight));
       
       if (move.length() > 0) {
           move.normalize().multiplyScalar(this.player.speed);
           const newPos = this.playerMesh.position.clone().add(move);
           
           if (Math.abs(newPos.x) < 48 && Math.abs(newPos.z) < 48) {
               this.playerMesh.position.copy(newPos);
           }
       }
       
       if (isMobile && this.touchData.aim.active) {
           this.mouse.x += this.touchData.aim.dx;
           this.mouse.y += this.touchData.aim.dy;
           this.mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.mouse.y));
       }
       
       this.playerMesh.rotation.y = -this.mouse.x;
   },
   
   updateCamera() {
       if (this.viewMode === 0) {
           this.camera.position.copy(this.playerMesh.position);
           this.camera.position.y += 1.7;
           this.camera.rotation.order = 'YXZ';
           this.camera.rotation.y = -this.mouse.x;
           this.camera.rotation.x = -this.mouse.y;
           
           if (this.weaponMesh) {
               this.weaponMesh.visible = true;
               this.weaponMesh.position.copy(this.camera.position);
               this.weaponMesh.rotation.copy(this.camera.rotation);
               this.weaponMesh.translateZ(-0.5);
               this.weaponMesh.translateY(-0.2);
               this.weaponMesh.translateX(0.3);
           }
       } else if (this.viewMode === 1) {
           const offset = new THREE.Vector3(0, 2, -4);
           offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), -this.mouse.x);
           this.camera.position.copy(this.playerMesh.position).add(offset);
           this.camera.lookAt(this.playerMesh.position);
           
           if (this.weaponMesh) {
               this.weaponMesh.visible = true;
               this.weaponMesh.position.copy(this.playerMesh.position);
               this.weaponMesh.rotation.y = -this.mouse.x;
               this.weaponMesh.translateZ(0.8);
               this.weaponMesh.translateY(1.3);
           }
       } else {
           const target = this.enemies.length > 0 ? this.enemies[0].mesh.position : new THREE.Vector3(0, 0, 0);
           const offset = new THREE.Vector3(3, 2, 3);
           this.camera.position.copy(this.playerMesh.position).add(offset);
           this.camera.lookAt(this.playerMesh.position);
           
           if (this.weaponMesh) this.weaponMesh.visible = false;
       }
   },
   
   getForwardVector() {
       const vec = new THREE.Vector3(0, 0, -1);
       vec.applyAxisAngle(new THREE.Vector3(0, 1, 0), -this.mouse.x);
       return vec;
   },
   
   updateBullets() {
       for (let i = this.bullets.length - 1; i >= 0; i--) {
           const b = this.bullets[i];
           b.mesh.position.add(b.velocity);
           b.life--;
           
           for (let enemy of this.enemies) {
               if (b.mesh.position.distanceTo(enemy.mesh.position) < 1) {
                   enemy.hp -= b.damage;
                   this.createHitEffect(enemy.mesh.position);
                   if (enemy.hp <= 0) {
                       this.killEnemy(enemy);
                   }
                   this.scene.remove(b.mesh);
                   this.bullets.splice(i, 1);
                   break;
               }
           }
           
           if (b.life <= 0 || b.mesh.position.length() > 100) {
               this.scene.remove(b.mesh);
               this.bullets.splice(i, 1);
           }
       }
   },
   
   updateEnemies() {
       for (let enemy of this.enemies) {
           const dir = new THREE.Vector3();
           dir.subVectors(this.playerMesh.position, enemy.mesh.position);
           dir.y = 0;
           dir.normalize();
           
           enemy.mesh.position.add(dir.multiplyScalar(enemy.speed));
           enemy.mesh.lookAt(this.playerMesh.position);
           
           if (enemy.mesh.position.distanceTo(this.playerMesh.position) < 1.5) {
               const now = Date.now();
               if (now - enemy.lastAttack > 1000) {
                   this.takeDamage(enemy.damage);
                   enemy.lastAttack = now;
               }
           }
       }
   },
   
   killEnemy(enemy) {
       this.scene.remove(enemy.mesh);
       this.enemies = this.enemies.filter(e => e !== enemy);
       this.score += enemy.reward;
       this.player.gold += enemy.reward;
       this.createExplosion(enemy.mesh.position);
       this.updateHUD();
   },
   
   takeDamage(amount) {
       this.player.hp -= amount;
       document.getElementById('damageOverlay').style.opacity = 1;
       setTimeout(() => document.getElementById('damageOverlay').style.opacity = 0, 300);
       
       if (isMobile && navigator.vibrate) {
           navigator.vibrate([50, 50, 50]);
       }
       
       if (this.player.hp <= 0) {
           this.gameOver();
       }
       this.updateHUD();
   },
   
   createHitEffect(pos) {
       const geo = new THREE.RingGeometry(0.1, 0.2, 8);
       const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true });
       const mesh = new THREE.Mesh(geo, mat);
       mesh.position.copy(pos);
       mesh.lookAt(this.camera.position);
       this.scene.add(mesh);
       this.particles.push({ mesh: mesh, life: 10, type: 'hit' });
   },
   
   createExplosion(pos) {
       for (let i = 0; i < 8; i++) {
           const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
           const mat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
           const mesh = new THREE.Mesh(geo, mat);
           mesh.position.copy(pos);
           const vel = new THREE.Vector3(
               (Math.random() - 0.5) * 0.3,
               Math.random() * 0.3,
               (Math.random() - 0.5) * 0.3
           );
           this.scene.add(mesh);
           this.particles.push({ mesh: mesh, velocity: vel, life: 30, type: 'debris' });
       }
   },
   
   updateParticles() {
       for (let i = this.particles.length - 1; i >= 0; i--) {
           const p = this.particles[i];
           p.life--;
           
           if (p.type === 'debris') {
               p.mesh.position.add(p.velocity);
               p.velocity.y -= 0.01;
               p.mesh.rotation.x += 0.1;
           } else if (p.type === 'hit') {
               p.mesh.scale.multiplyScalar(1.1);
               p.mesh.material.opacity = p.life / 10;
           }
           
           if (p.life <= 0) {
               this.scene.remove(p.mesh);
               this.particles.splice(i, 1);
           }
       }
   },
   
   updateHUD() {
       document.getElementById('hpDisplay').textContent = Math.max(0, this.player.hp);
       document.getElementById('ammoDisplay').textContent = `${this.player.ammo}/${this.player.reserveAmmo}`;
       document.getElementById('scoreDisplay').textContent = this.score;
       document.getElementById('waveDisplay').textContent = this.wave;
       document.getElementById('weaponDisplay').textContent = this.currentWeapon.name;
       document.getElementById('goldDisplay').textContent = this.player.gold;
   },
   
   startMode(mode) {
       this.mode = mode;
       this.isPlaying = true;
       this.isPaused = false;
       this.player.hp = 100;
       this.player.ammo = 30;
       this.player.reserveAmmo = 90;
       this.score = 0;
       this.wave = 1;
       this.enemies.forEach(e => this.scene.remove(e.mesh));
       this.enemies = [];
       this.bullets.forEach(b => this.scene.remove(b.mesh));
       this.bullets = [];
       
       document.getElementById('mainMenu').classList.add('hidden');
       document.getElementById('gameUI').classList.remove('hidden');
       
       if (mode === 'creator') {
           this.isPlaying = false;
           ui.showCreator();
       } else {
           if (!isMobile) {
               this.renderer.domElement.requestPointerLock();
           }
           for (let i = 0; i < 3; i++) this.spawnEnemy();
       }
       
       this.updateHUD();
   },
   
   togglePause() {
       if (!this.isPlaying) return;
       this.isPaused = !this.isPaused;
       if (this.isPaused) {
           if (!isMobile) document.exitPointerLock();
           document.getElementById('pauseMenu').classList.remove('hidden');
       } else {
           document.getElementById('pauseMenu').classList.add('hidden');
           if (!isMobile) this.renderer.domElement.requestPointerLock();
       }
   },
   
   resume() {
       this.isPaused = false;
       document.getElementById('pauseMenu').classList.add('hidden');
       if (!isMobile) this.renderer.domElement.requestPointerLock();
   },
   
   returnToMenu() {
       this.isPlaying = false;
       this.isPaused = false;
       this.isFiring = false;
       if (!isMobile) document.exitPointerLock();
       document.getElementById('gameUI').classList.add('hidden');
       document.getElementById('pauseMenu').classList.add('hidden');
       document.getElementById('mainMenu').classList.remove('hidden');
   },
   
   gameOver() {
       this.isPlaying = false;
       this.isFiring = false;
       if (!isMobile) document.exitPointerLock();
       setTimeout(() => {
           alert(`æ¸¸æˆç»“æŸï¼\næ¨¡å¼: ${this.mode}\nåˆ†æ•°: ${this.score}\næ³¢æ¬¡: ${this.wave}`);
           this.returnToMenu();
       }, 100);
   },
   
   startArenaMatch() {
       alert('æ­£åœ¨åŒ¹é…ç«æŠ€åœºå¯¹æ‰‹...');
       this.startMode('arena');
   },
   
   animate() {
       requestAnimationFrame(() => this.animate());
       this.update();
       this.renderer.render(this.scene, this.camera);
   }
};

const ui = {
   showStore() {
       const grid = document.getElementById('storeGrid');
       grid.innerHTML = '';
       document.getElementById('storeGold').textContent = game.player.gold;
       
       game.weapons.forEach(weapon => {
           const div = document.createElement('div');
           div.className = 'slot p-4 rounded cursor-pointer';
           div.innerHTML = `
               <div class="text-cyan-400 font-bold text-sm md:text-base">${weapon.name}</div>
               <div class="text-cyan-200 text-xs md:text-sm">ä¼¤å®³: ${weapon.damage}</div>
               <div class="text-cyan-200 text-xs md:text-sm">å°„é€Ÿ: ${weapon.fireRate}ms</div>
               <div class="text-yellow-400 text-xs md:text-sm mt-1">${weapon.unlocked ? 'å·²æ‹¥æœ‰' : weapon.price + 'é‡‘å¸'}</div>
           `;
           div.onclick = () => this.buyWeapon(weapon);
           grid.appendChild(div);
       });
       
       document.getElementById('storeModal').classList.remove('hidden');
   },
   
   buyWeapon(weapon) {
       if (weapon.unlocked) {
           game.currentWeapon = weapon;
           game.createWeaponMesh();
           alert('å·²è£…å¤‡ ' + weapon.name);
       } else if (game.player.gold >= weapon.price) {
           game.player.gold -= weapon.price;
           weapon.unlocked = true;
           game.currentWeapon = weapon;
           game.createWeaponMesh();
           document.getElementById('storeGold').textContent = game.player.gold;
           this.showStore();
           game.updateHUD();
       } else {
           alert('é‡‘å¸ä¸è¶³ï¼');
       }
   },
   
   showInventory() {
       const grid = document.getElementById('inventoryGrid');
       grid.innerHTML = '';
       
       for (let i = 0; i < 32; i++) {
           const slot = document.createElement('div');
           slot.className = 'slot h-12 md:h-16 rounded cursor-pointer flex items-center justify-center';
           if (i === 0) slot.innerHTML = '<span class="text-cyan-400 text-xs">åŒ»ç–—åŒ…</span>';
           if (i === 1) slot.innerHTML = '<span class="text-cyan-400 text-xs">å¼¹è¯ç®±</span>';
           grid.appendChild(slot);
       }
       
       const equipped = document.getElementById('equippedItems');
       equipped.innerHTML = '';
       game.weapons.filter(w => w.unlocked).forEach(w => {
           const div = document.createElement('div');
           div.className = 'slot p-2 rounded text-cyan-400 text-xs md:text-sm cursor-pointer';
           div.textContent = w.name;
           div.onclick = () => { game.currentWeapon = w; game.createWeaponMesh(); };
           equipped.appendChild(div);
       });
       
       document.getElementById('inventoryModal').classList.remove('hidden');
   },
   
   showWarehouse() {
       const grid = document.getElementById('warehouseGrid');
       grid.innerHTML = '';
       for (let i = 0; i < 50; i++) {
           const slot = document.createElement('div');
           slot.className = 'slot h-10 md:h-12 rounded';
           grid.appendChild(slot);
       }
       document.getElementById('warehouseModal').classList.remove('hidden');
   },
   
   showQuests() {
       const list = document.getElementById('questList');
       list.innerHTML = '';
       const quests = [
           { name: 'åˆå‡ºèŒ…åº', desc: 'æ¶ˆç­10ä¸ªæ•Œäºº', reward: '100é‡‘å¸', progress: '5/10' },
           { name: 'ç”Ÿå­˜ä¸“å®¶', desc: 'ç”Ÿå­˜10æ³¢', reward: '500é‡‘å¸', progress: '3/10' },
           { name: 'æ­¦å™¨å¤§å¸ˆ', desc: 'è§£é”æ‰€æœ‰æ­¦å™¨', reward: '2000é‡‘å¸', progress: '2/5' },
           { name: 'ç«æŠ€ç‹è€…', desc: 'èµ¢å¾—3åœºç«æŠ€åœºæ¯”èµ›', reward: 'ä¼ è¯´çš®è‚¤', progress: '0/3' }
       ];
       
       quests.forEach(q => {
           const div = document.createElement('div');
           div.className = 'slot p-4 rounded flex flex-col md:flex-row justify-between items-start md:items-center gap-2';
           div.innerHTML = `
               <div>
                   <div class="text-cyan-400 font-bold">${q.name}</div>
                   <div class="text-cyan-200 text-sm">${q.desc}</div>
                   <div class="text-yellow-400 text-xs md:text-sm">å¥–åŠ±: ${q.reward}</div>
               </div>
               <div class="text-cyan-400 text-sm">${q.progress}</div>
           `;
           list.appendChild(div);
       });
       
       document.getElementById('questModal').classList.remove('hidden');
   },
   
   showArena() {
       const list = document.getElementById('arenaList');
       list.innerHTML = '';
       const players = ['NightStalker', 'CyberNinja', 'NeonRider', 'VoidWalker', 'StarKiller'];
       players.forEach((p, i) => {
           const div = document.createElement('div');
           div.className = 'slot p-3 rounded flex justify-between text-cyan-400 text-sm';
           div.innerHTML = `<span>${i + 1}. ${p}</span><span>èƒœç‡: ${80 - i * 10}%</span>`;
           list.appendChild(div);
       });
       document.getElementById('arenaModal').classList.remove('hidden');
   },
   
   showCreator() {
       document.getElementById('creatorModal').classList.remove('hidden');
   },
   
   closeModal(id) {
       document.getElementById(id).classList.add('hidden');
   }
};

const creator = {
   placing: null,
   
   placeEnemy() {
       this.placing = 'enemy';
       document.getElementById('creatorModal').classList.add('hidden');
       game.renderer.domElement.addEventListener('click', this.onPlace);
   },
   
   placeWall() {
       this.placing = 'wall';
       document.getElementById('creatorModal').classList.add('hidden');
   },
   
   placeItem() {
       this.placing = 'item';
       document.getElementById('creatorModal').classList.add('hidden');
   },
   
   setSpawn() {
       alert('å‡ºç”Ÿç‚¹å·²è®¾ç½®');
   },
   
   saveMap() {
       alert('åœ°å›¾å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
   },
   
   loadMap() {
       alert('åœ°å›¾å·²åŠ è½½');
   },
   
   clearMap() {
       game.enemies.forEach(e => game.scene.remove(e.mesh));
       game.enemies = [];
       alert('åœ°å›¾å·²æ¸…ç©º');
   },
   
   testMap() {
       ui.closeModal('creatorModal');
       game.startMode('creator');
   },
   
   onPlace(e) {
       if (!creator.placing) return;
       const raycaster = new THREE.Raycaster();
       const mouse = new THREE.Vector2();
       mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
       mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
       raycaster.setFromCamera(mouse, game.camera);
       const intersects = raycaster.intersectObjects(game.scene.children);
       
       if (intersects.length > 0) {
           const point = intersects[0].point;
           if (creator.placing === 'enemy') {
               const mesh = new THREE.Mesh(
                   new THREE.BoxGeometry(0.8, 1.8, 0.8),
                   new THREE.MeshStandardMaterial({ color: 0xff0000 })
               );
               mesh.position.copy(point);
               mesh.position.y = 0.9;
               game.scene.add(mesh);
               game.enemies.push({
                   mesh: mesh,
                   hp: 50,
                   speed: 0.05,
                   damage: 10,
                   type: 'custom'
               });
           }
       }
       creator.placing = null;
       game.renderer.domElement.removeEventListener('click', creator.onPlace);
   }
};

window.onload = () => game.init();
</script>
</body>
</html>
