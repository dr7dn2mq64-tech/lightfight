<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LightFight</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; touch-action: none; }
        body { background: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: monospace; }
        #canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        .hud { position: fixed; z-index: 10; pointer-events: none; }
        .hud-box { background: rgba(0,20,40,0.8); border: 1px solid #0ff; padding: 10px; color: #0ff; }
        .hud.left { top: 20px; left: 20px; }
        .hud.right { top: 20px; right: 20px; text-align: right; }
        
        #controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 320px; z-index: 20; display: none; pointer-events: none; }
        #controls.active { display: block; }
        
        /* Left Move Stick */
        .stick { position: absolute; width: 140px; height: 140px; pointer-events: auto; touch-action: none; left: 30px; bottom: 40px; }
        .stick-base { width: 140px; height: 140px; background: rgba(0,255,255,0.15); border: 2px solid rgba(0,255,255,0.6); border-radius: 50%; position: absolute; }
        .stick-knob { width: 60px; height: 60px; background: rgba(0,255,255,0.9); border-radius: 50%; position: absolute; top: 40px; left: 40px; box-shadow: 0 0 15px #0ff; transition: transform 0.05s; }
        
        /* Right Action Buttons - ÊâãÁªòÂõæÂ∏ÉÂ±Ä */
        .fire-btn { position: absolute; right: 30px; bottom: 90px; width: 100px; height: 100px; background: rgba(255,30,30,0.4); border: 3px solid #ff4444; border-radius: 50%; pointer-events: auto; color: #fff; font-weight: bold; font-size: 16px; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 20px rgba(255,0,0,0.4); z-index: 30; }
        .fire-btn:active { background: rgba(255,30,30,0.7); transform: scale(0.95); }
        
        /* Ë∑≥/Ëπ≤ - ÊâãÁªòÂõæ‰∏≠ÁöÑÁªøËâ≤ÊåâÈíÆ */
        .action-btn { position: absolute; width: 65px; height: 65px; background: rgba(0,255,100,0.25); border: 2px solid #00ff66; border-radius: 50%; pointer-events: auto; color: #0f6; font-weight: bold; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 30; text-shadow: 0 0 5px #0f6; }
        .action-btn:active { background: rgba(0,255,100,0.5); }
        #jumpBtn { right: 150px; bottom: 150px; }
        #crouchBtn { right: 150px; bottom: 60px; font-size: 16px; }
        
        /* Center Menu */
        .center-menu { position: absolute; bottom: 25px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; pointer-events: auto; }
        .cbtn { background: rgba(0,0,0,0.6); border: 1px solid #0ff; color: #0ff; padding: 10px 18px; font-size: 12px; backdrop-filter: blur(5px); pointer-events: auto; z-index: 30; }
        
        /* Touch area for look - Âè≥ÂçäÂ±èÊªëÂä®Âå∫ */
        .look-area { position: absolute; right: 0; top: 0; width: 50%; height: 100%; pointer-events: auto; z-index: 5; }
        
        #menu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at center,#0a2436 0%,#000 100%); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .title { font-size: 3.5rem; color: #0ff; text-shadow: 0 0 30px #0ff; margin-bottom: 40px; font-weight: bold; letter-spacing: 6px; }
        .btn { background: transparent; border: 2px solid #0ff; color: #0ff; padding: 14px 50px; margin: 8px; font-size: 1.1rem; cursor: pointer; width: 280px; text-align: center; transition: all 0.2s; letter-spacing: 2px; }
        .btn:active { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
        
        /* Hit marker */
        #hitmarker { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 40px; height: 40px; opacity: 0; pointer-events: none; z-index: 25; }
        #hitmarker.show { opacity: 1; animation: hit 0.2s forwards; }
        @keyframes hit { 0%{transform:translate(-50%,-50%) scale(0.5);} 50%{transform:translate(-50%,-50%) scale(1.2);} 100%{transform:translate(-50%,-50%) scale(1); opacity:0;} }
        
        .crosshair { position: fixed; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid #0ff; border-radius: 50%; transform: translate(-50%,-50%); pointer-events: none; z-index: 20; box-shadow: 0 0 10px #0ff; transition: transform 0.05s; }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>
<div class="crosshair" id="crosshair"></div>

<!-- Hit Marker X -->
<svg id="hitmarker" viewBox="0 0 40 40">
    <line x1="5" y1="5" x2="15" y2="15" stroke="#fff" stroke-width="3"/>
    <line x1="35" y1="5" x2="25" y2="15" stroke="#fff" stroke-width="3"/>
    <line x1="5" y1="35" x2="15" y2="25" stroke="#fff" stroke-width="3"/>
    <line x1="35" y1="35" x2="25" y2="25" stroke="#fff" stroke-width="3"/>
</svg>

<div class="hud left hud-box">
    <div style="font-size:22px;font-weight:bold;text-shadow:0 0 10px #0ff;">HP: <span id="hp">100</span></div>
    <div style="margin-top:8px;color:#fd0;text-shadow:0 0 5px #fd0;">üí∞ <span id="gold">0</span></div>
    <div style="font-size:13px;margin-top:8px;opacity:0.9;">Â≠êÂºπ: <span id="ammo">30/90</span></div>
</div>

<div class="hud right hud-box">
    <div style="font-size:18px;font-weight:bold;color:#0ff;text-shadow:0 0 8px #0ff;" id="weaponName">Ëá™Âä®Ê≠•Êû™</div>
    <div style="font-size:12px;color:#888;margin-top:4px;">Wave <span id="wave">1</span></div>
</div>

<div id="controls">
    <!-- Â∑¶ÊëáÊùÜÁßªÂä® -->
    <div class="stick" id="moveStick">
        <div class="stick-base"></div>
        <div class="stick-knob" id="moveKnob"></div>
    </div>
    
    <!-- Âè≥ÂçäÂ±èÊªëÂä®ËßÜËßí (ÈÄèÊòé) -->
    <div class="look-area" id="lookArea"></div>
    
    <!-- Âè≥‰æßÂäüËÉΩÊåâÈíÆ -->
    <div class="fire-btn" id="fireBtn">ÂºÄÁÅ´</div>
    <div class="action-btn" id="jumpBtn">Ë∑≥</div>
    <div class="action-btn" id="crouchBtn">Ëπ≤</div>
    
    <!-- Â∫ïÈÉ®ËèúÂçï -->
    <div class="center-menu">
        <button class="cbtn" onclick="game.pause()">||</button>
        <button class="cbtn" onclick="game.switchView()">ËßÜËßí</button>
        <button class="cbtn" onclick="game.reload()">Êç¢Âºπ</button>
    </div>
</div>

<div id="menu">
    <div class="title">LIGHTFIGHT</div>
    <button class="btn" onclick="game.start('story')">ÂâßÊÉÖÊ®°Âºè</button>
    <button class="btn" onclick="game.start('endless')">Êó†Â∞ΩÊ®°Âºè</button>
    <button class="btn" onclick="game.start('survival')">ÁîüÂ≠òÊåëÊàò</button>
    <div style="height:20px;"></div>
    <button class="btn" onclick="game.start('creator')">ÈÄ†Áâ©Ê®°Âºè</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const game={
    state:'menu',
    hp:100,maxHp:100,
    ammo:30,reserve:90,
    gold:0,wave:1,
    viewMode:0,
    sensitivity:0.005,
    
    move:{x:0,y:0},
    look:{x:0,y:0},
    crouch:false,
    isFiring:false,
    lastFire:0,
    
    scene:null,camera:null,renderer:null,
    player:null,weaponMesh:null,
    enemies:[],bullets:[],
    
    init(){
        const canvas=document.getElementById('canvas');
        
        // Scene
        this.scene=new THREE.Scene();
        this.scene.background=new THREE.Color(0x051015);
        this.scene.fog=new THREE.Fog(0x051015,8,50);
        
        this.camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
        this.renderer=new THREE.WebGLRenderer({canvas:canvas,antialias:true});
        this.renderer.setSize(window.innerWidth,window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
        this.renderer.shadowMap.enabled=true;
        
        // Lights
        const ambient=new THREE.AmbientLight(0x6688aa,0.7);
        this.scene.add(ambient);
        
        const dir=new THREE.DirectionalLight(0xffffff,0.9);
        dir.position.set(15,30,10);
        dir.castShadow=true;
        this.scene.add(dir);
        
        // Floor
        const floor=new THREE.Mesh(
            new THREE.PlaneGeometry(200,200),
            new THREE.MeshStandardMaterial({color:0x0a1a2a,roughness:0.8})
        );
        floor.rotation.x=-Math.PI/2;
        floor.receiveShadow=true;
        this.scene.add(floor);
        
        // Grid
        const grid=new THREE.GridHelper(200,50,0x00ffff,0x003344);
        grid.position.y=0.01;
        this.scene.add(grid);
        
        // Buildings
        for(let i=0;i<25;i++){
            const h=2+Math.random()*8;
            const geo=new THREE.BoxGeometry(2+Math.random()*3,h,2+Math.random()*3);
            const mat=new THREE.MeshLambertMaterial({
                color:[0xff0066,0x00ff88,0xffff00,0xff6600,0x0066ff][Math.floor(Math.random()*5)]
            });
            const mesh=new THREE.Mesh(geo,mat);
            mesh.position.set((Math.random()-0.5)*80,h/2,(Math.random()-0.5)*80);
            mesh.castShadow=true;
            this.scene.add(mesh);
        }
        
        // Player Group
        this.player=new THREE.Group();
        this.player.position.set(0,0,0);
        this.scene.add(this.player);
        
        // Weapon (FPS view visible)
        const gunGeo=new THREE.BoxGeometry(0.15,0.2,0.8);
        const gunMat=new THREE.MeshStandardMaterial({color:0x444444,roughness:0.3,metalness:0.8});
        this.weaponMesh=new THREE.Mesh(gunGeo,gunMat);
        this.weaponMesh.position.set(0.4,0.2,0.4);
        this.player.add(this.weaponMesh);
        
        // Crosshair update
        this.crosshair=document.getElementById('crosshair');
        
        // Events
        this.setupControls();
        window.addEventListener('resize',()=>{
            this.camera.aspect=window.innerWidth/window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth,window.innerHeight);
        });
        
        this.animate();
    },
    
    setupControls(){
        // Left Stick - Move
        const stick=document.getElementById('moveStick');
        const knob=document.getElementById('moveKnob');
        let active=false,cx,cy;
        
        stick.addEventListener('touchstart',e=>{
            e.preventDefault();active=true;
            const r=stick.getBoundingClientRect();
            cx=r.left+70;cy=r.top+70;
            this.updateStick(e.touches[0],cx,cy,knob);
        },{passive:false});
        
        stick.addEventListener('touchmove',e=>{
            e.preventDefault();if(!active)return;
            this.updateStick(e.touches[0],cx,cy,knob);
        },{passive:false});
        
        const end=(e)=>{
            e.preventDefault();active=false;
            this.move.x=0;this.move.y=0;
            knob.style.transform='translate(0,0)';
        };
        stick.addEventListener('touchend',end,{passive:false});
        stick.addEventListener('touchcancel',end,{passive:false});
        
        // Look Area - Âè≥ÂçäÂ±èÊªëÂä®ËΩ¨ËßÜËßí
        const lookArea=document.getElementById('lookArea');
        let lookTouch=null,lastX=0,lastY=0;
        
        lookArea.addEventListener('touchstart',e=>{
            for(let t of e.changedTouches){
                if(t.clientX>window.innerWidth/2 && !lookTouch){
                    lookTouch=t.identifier;
                    lastX=t.clientX;lastY=t.clientY;
                }
            }
        },{passive:true});
        
        lookArea.addEventListener('touchmove',e=>{
            if(!lookTouch)return;
            for(let t of e.changedTouches){
                if(t.identifier===lookTouch){
                    const dx=t.clientX-lastX;
                    const dy=t.clientY-lastY;
                    this.player.rotation.y-=dx*this.sensitivity;
                    // Pitch (optional - Â¶ÇÊûúÈúÄË¶Å‰∏ä‰∏ãÁúãÂèØ‰ª•ÂèñÊ∂àÊ≥®Èáä)
                    // this.camera.rotation.x-=dy*this.sensitivity;
                    lastX=t.clientX;lastY=t.clientY;
                    e.preventDefault();
                }
            }
        },{passive:false});
        
        const endLook=(e)=>{
            for(let t of e.changedTouches){
                if(t.identifier===lookTouch)lookTouch=null;
            }
        };
        lookArea.addEventListener('touchend',endLook,{passive:true});
        lookArea.addEventListener('touchcancel',endLook,{passive:true});
        
        // PC Mouse Look (click to lock)
        document.addEventListener('mousemove',e=>{
            if(document.pointerLockElement===document.getElementById('canvas')){
                this.player.rotation.y-=e.movementX*0.002;
            }
        });
        
        document.getElementById('canvas').addEventListener('click',()=>{
            if(this.state==='playing' && !this.isMobile()){
                document.getElementById('canvas').requestPointerLock();
            }
        });
        
        // Buttons
        document.getElementById('fireBtn').addEventListener('touchstart',e=>{
            e.preventDefault();this.isFiring=true;this.fire();
        });
        document.getElementById('fireBtn').addEventListener('touchend',e=>{
            e.preventDefault();this.isFiring=false;
        });
        
        document.getElementById('jumpBtn').addEventListener('touchstart',e=>{
            e.preventDefault();this.jump();
        });
        
        document.getElementById('crouchBtn').addEventListener('touchstart',e=>{
            e.preventDefault();this.crouch=!this.crouch;
            e.target.style.background=this.crouch?'rgba(0,255,100,0.6)':'rgba(0,255,100,0.25)';
        });
        
        // Keyboard
        this.keys={};
        document.addEventListener('keydown',e=>{
            this.keys[e.key.toLowerCase()]=true;
            if(e.key===' ' || e.key==='Spacebar')this.jump();
            if(e.key==='c' || e.key==='C'){this.crouch=!this.crouch;}
            if(e.key==='r' || e.key==='R')this.reload();
            if(e.key==='v' || e.key==='V')this.switchView();
            if(e.key==='Escape')this.pause();
        });
        document.addEventListener('keyup',e=>this.keys[e.key.toLowerCase()]=false);
        document.addEventListener('mousedown',()=>{
            if(!this.isMobile() && this.state==='playing')this.fire();
        });
    },
    
    updateStick(touch,cx,cy,knob){
        const max=35;
        let dx=touch.clientX-cx,dy=touch.clientY-cy;
        const d=Math.sqrt(dx*dx+dy*dy);
        if(d>max){dx=(dx/d)*max;dy=(dy/d)*max;}
        knob.style.transform=`translate(${dx}px,${dy}px)`;
        this.move.x=dx/max;
        this.move.y=dy/max;
    },
    
    isMobile(){return 'ontouchstart' in window || navigator.maxTouchPoints>0;},
    
    start(mode){
        this.state='playing';
        this.mode=mode;
        this.hp=100;this.ammo=30;this.wave=1;this.gold=0;
        this.player.position.set(0,0,0);
        
        // Clear old enemies
        this.enemies.forEach(e=>this.scene.remove(e.mesh));
        this.enemies=[];
        
        for(let i=0;i<3;i++)this.spawnEnemy();
        
        document.getElementById('menu').style.display='none';
        document.getElementById('controls').classList.add('active');
        this.updateHUD();
    },
    
    spawnEnemy(){
        const geo=new THREE.BoxGeometry(0.8,1.8,0.8);
        const mat=new THREE.MeshLambertMaterial({color:0xff0033});
        const mesh=new THREE.Mesh(geo,mat);
        
        // Spwan away from player
        const angle=Math.random()*Math.PI*2;
        const dist=15+Math.random()*15;
        mesh.position.set(
            this.player.position.x+Math.cos(angle)*dist,
            0.9,
            this.player.position.z+Math.sin(angle)*dist
        );
        
        mesh.castShadow=true;
        this.scene.add(mesh);
        
        this.enemies.push({
            mesh:mesh,
            hp:100,
            maxHp:100,
            speed:0.03+Math.random()*0.02,
            lastAttack:0,
            dead:false
        });
    },
    
    fire(){
        const now=Date.now();
        if(now-this.lastFire<100)return; // Fire rate limit
        this.lastFire=now;
        
        if(this.ammo<=0){this.reload();return;}
        this.ammo--;
        this.updateHUD();
        
        // Recoil animation
        this.crosshair.style.transform='translate(-50%,-50%) scale(1.5)';
        setTimeout(()=>this.crosshair.style.transform='translate(-50%,-50%) scale(1)',50);
        
        // Weapon recoil
        this.weaponMesh.position.z=0.3;
        setTimeout(()=>this.weaponMesh.position.z=0.4,100);
        
        // Bullet
        const bullet=new THREE.Mesh(
            new THREE.SphereGeometry(0.08,8,8),
            new THREE.MeshBasicMaterial({color:0xffff00})
        );
        
        // Start from gun position
        const startPos=new THREE.Vector3();
        this.weaponMesh.getWorldPosition(startPos);
        bullet.position.copy(startPos);
        
        // Direction based on player rotation
        const dir=new THREE.Vector3(0,0,-1);
        dir.applyQuaternion(this.player.quaternion);
        
        this.bullets.push({
            mesh:bullet,
            dir:dir,
            speed:1.5,
            life:60, // frames
            playerPos:startPos.clone() // For distance check
        });
        this.scene.add(bullet);
        
        // Auto fire if holding
        if(this.isFiring){
            setTimeout(()=>this.fire(),100);
        }
    },
    
    jump(){
        if(this.player.position.y<=0.01){
            this.jumpVel=0.4;
        }
    },
    
    reload(){
        if(this.reserve>0){
            const need=30-this.ammo;
            const take=Math.min(need,this.reserve);
            this.ammo+=take;
            this.reserve-=take;
            this.updateHUD();
        }
    },
    
    switchView(){
        this.viewMode=(this.viewMode+1)%2;
        const names=['Á¨¨‰∏Ä‰∫∫Áß∞','Á¨¨‰∏â‰∫∫Áß∞'];
        document.getElementById('weaponName').textContent=names[this.viewMode]+' ¬∑ Ëá™Âä®Ê≠•Êû™';
    },
    
    pause(){
        if(confirm('ÊöÇÂÅúÊ∏∏Êàè\nÁÇπÂáªÁ°ÆÂÆöËøîÂõû‰∏ªËèúÂçï')){
            location.reload();
        }
    },
    
    update(){
        if(this.state!=='playing')return;
        
        // Physics - Jump
        if(this.jumpVel>0||this.player.position.y>0){
            this.player.position.y+=this.jumpVel;
            this.jumpVel-=0.02;
            if(this.player.position.y<0){
                this.player.position.y=0;
                this.jumpVel=0;
            }
        }
        
        // Movement
        const speed=this.crouch?0.06:0.12;
        const forward=new THREE.Vector3(0,0,-1).applyQuaternion(this.player.quaternion);
        const right=new THREE.Vector3(1,0,0).applyQuaternion(this.player.quaternion);
        
        let mx=0,my=0;
        
        // Keyboard
        if(this.keys) {
            if(this.keys['w'])my+=1;
            if(this.keys['s'])my-=1;
            if(this.keys['a'])mx-=1;
            if(this.keys['d'])mx+=1;
        }
        
        // Touch override
        if(this.move.x!==0||this.move.y!==0){
            mx=this.move.x;
            my=-this.move.y;
        }
        
        if(mx!==0||my!==0){
            const moveDir=forward.clone().multiplyScalar(my).add(right.clone().multiplyScalar(mx)).normalize();
            this.player.position.add(moveDir.multiplyScalar(speed));
        }
        
        // Camera Update
        if(this.viewMode===0){ // FPS
            this.camera.position.copy(this.player.position);
            this.camera.position.y=1.6+(this.crouch?-0.4:0)+(this.player.position.y>0?this.player.position.y:0);
            this.camera.rotation.order='YXZ';
            this.camera.rotation.y=this.player.rotation.y;
            // Optional pitch
            
            this.weaponMesh.visible=true;
        }else{ // TPS
            const offset=new THREE.Vector3(0,3,-5).applyQuaternion(this.player.quaternion);
            this.camera.position.copy(this.player.position).add(offset);
            this.camera.lookAt(this.player.position);
            this.camera.position.y+=this.player.position.y>0?this.player.position.y:0;
            this.weaponMesh.visible=false;
        }
        
        // Enemy AI
        const now=Date.now();
        this.enemies.forEach((enemy,index)=>{
            if(enemy.dead)return;
            
            const dir=new THREE.Vector3().subVectors(this.player.position,enemy.mesh.position);
            const dist=dir.length();
            dir.y=0;dir.normalize();
            
            // Move toward player
            if(dist>1.2){
                enemy.mesh.position.add(dir.multiplyScalar(enemy.speed));
            }
            
            // Face player
            enemy.mesh.lookAt(this.player.position);
            
            // Attack
            if(dist<1.8 && now-enemy.lastAttack>1200){
                this.takeDamage(15);
                enemy.lastAttack=now;
            }
        });
        
        // Bullet Physics & Hit Detection - Fixed!
        for(let i=this.bullets.length-1;i>=0;i--){
            const b=this.bullets[i];
            
            // Move bullet
            b.mesh.position.add(b.dir.clone().multiplyScalar(b.speed));
            b.life--;
            
            // Hit detection - use distance check with continuous collision
            // Bullet is point, enemy is box approximately 0.8x1.8x0.8
            let hit=false;
            
            for(let j=this.enemies.length-1;j>=0;j--){
                const e=this.enemies[j];
                if(e.dead)continue;
                
                // Distance between bullet and enemy center
                const dist=b.mesh.position.distanceTo(e.mesh.position);
                
                // Hit threshold - enemy is roughly 0.8 wide and 1.8 tall
                // Check if bullet is within 1 unit horizontally and reasonable vertically
                const dx=Math.abs(b.mesh.position.x-e.mesh.position.x);
                const dz=Math.abs(b.mesh.position.z-e.mesh.position.z);
                const dy=Math.abs(b.mesh.position.y-e.mesh.position.y);
                
                // Hit box: 1.0 width, 2.0 height centered at 0.9
                if(dx<0.6 && dz<0.6 && dy<1.0){
                    // HIT!
                    hit=true;
                    e.hp-=25;
                    
                    // Hit marker
                    document.getElementById('hitmarker').classList.add('show');
                    setTimeout(()=>document.getElementById('hitmarker').classList.remove('show'),200);
                    
                    // Visual feedback - flash enemy white
                    e.mesh.material.emissive=new THREE.Color(0xffffff);
                    setTimeout(()=>{
                        if(!e.dead)e.mesh.material.emissive=new THREE.Color(0x000000);
                    },50);
                    
                    if(e.hp<=0){
                        e.dead=true;
                        this.scene.remove(e.mesh);
                        this.enemies.splice(j,1);
                        this.gold+=50;
                        this.score=this.score?this.score+100:100;
                    }
                    break;
                }
            }
            
            // Remove if hit or timeout or too far
            if(hit || b.life<=0 || b.mesh.position.length()>100){
                this.scene.remove(b.mesh);
                this.bullets.splice(i,1);
            }
        }
        
        // Spawning
        if(this.enemies.length===0){
            this.wave++;
            for(let i=0;i<3+this.wave;i++)this.spawnEnemy();
            this.updateHUD();
        }
        
        // Ammo auto regen (slow)
        if(this.ammo===0 && this.reserve>0 && Math.random()<0.01){
            this.reload();
        }
    },
    
    takeDamage(amount){
        this.hp-=amount;
        this.updateHUD();
        // Flash red
        document.body.style.background='#400';
        setTimeout(()=>document.body.style.background='#000',100);
        
        if(this.hp<=0){
            alert('‰ªªÂä°Â§±Ë¥•!\nÂáªË¥•Ê≥¢Ê¨°: '+this.wave+'\nËé∑ÂæóÈáëÂ∏Å: '+this.gold);
            location.reload();
        }
    },
    
    updateHUD(){
        document.getElementById('hp').textContent=this.hp;
        document.getElementById('ammo').textContent=this.ammo+'/'+this.reserve;
        document.getElementById('gold').textContent=this.gold;
        document.getElementById('wave').textContent=this.wave;
    },
    
    animate(){
        requestAnimationFrame(()=>this.animate());
        this.update();
        this.renderer.render(this.scene,this.camera);
    }
};

window.onload=()=>game.init();
</script>
</body>
</html>
